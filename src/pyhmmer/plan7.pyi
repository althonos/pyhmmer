# coding: utf-8
import collections.abc
import datetime
import enum
import os
import sys
import types
import typing
from typing import (
    Any, 
    ClassVar,
    Dict,
    Iterable,
    Iterator,
    List,
    Optional,
    Union,
)

try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal  # type: ignore

from .utils import SizedIterator
from .easel import (
    Alphabet,
    Sequence,
    DigitalSequence,
    DigitalSequenceBlock,
    KeyHash,
    MSA,
    DigitalMSA,
    TextMSA,
    Randomness,
    SequenceFile,
    VectorF,
    VectorU8,
    MatrixF,
    MatrixU8,
)

BIT_CUTOFFS = Literal["gathering", "trusted", "noise"]
SORT_KEY = Literal["key", "seqidx"]
ARCHITECTURE = Literal["fast", "hand"]
WEIGHTING = Literal["pb", "gsc", "blosum", "none", "given"]
EFFECTIVE = Literal["entropy", "exp", "clust", "none"]
PRIOR_SCHEME = Literal["laplace", "alphabet"]
STRAND = Literal["watson", "crick"]
STRAND_SIGN = Literal["+", "-"]
HITS_FORMAT = Literal["targets", "domain", "pfam"]
HITS_MODE = Literal["search", "scan"]

ABC = typing.TypeVar("ABC", bound=Alphabet)
Q = typing.TypeVar("Q")  # pipeline query type

class Alignment(collections.abc.Sized):
    domain: Domain
    def __len__(self) -> int: ...
    def __getstate__(self) -> Dict[str, object]: ...
    def __setstate__(self, state: Dict[str, object]) -> None: ...
    @property
    def hmm_accession(self) -> str: ...
    @property
    def hmm_from(self) -> int: ...
    @property
    def hmm_length(self) -> int: ...
    @property
    def hmm_name(self) -> str: ...
    @property
    def hmm_sequence(self) -> str: ...
    @property
    def hmm_to(self) -> int: ...
    @property
    def posterior_probabilities(self) -> str: ...
    @property
    def target_from(self) -> int: ...
    @property
    def target_length(self) -> int: ...
    @property
    def target_name(self) -> str: ...
    @property
    def target_sequence(self) -> str: ...
    @property
    def target_to(self) -> int: ...
    @property
    def identity_sequence(self) -> str: ...

class Background(typing.Generic[ABC]):
    def __init__(
        self, 
        alphabet: ABC, 
        uniform: bool = False
    ) -> None: ...
    def __copy__(self) -> Background[ABC]: ...
    @property
    def L(self) -> int: ...
    @L.setter
    def L(self, L: int) -> None: ...
    @property
    def residue_frequencies(self) -> VectorF: ...
    @property
    def transition_probability(self) -> float: ...
    @property
    def omega(self) -> float: ...
    @omega.setter
    def omega(self, omega: float) -> None: ...
    def copy(self) -> Background[ABC]: ...

class Builder(typing.Generic[ABC]):
    _ARCHITECTURE_STRATEGY: ClassVar[Dict[str, int]]
    _WEIGHTING_STRATEGY: ClassVar[Dict[str, int]]
    _EFFECTIVE_STRATEGY: ClassVar[Dict[str, int]]
    alphabet: ABC
    randomness: Randomness
    score_matrix: str
    architecture: ARCHITECTURE
    weighting: WEIGHTING
    effective_number: Union[EFFECTIVE, int, float]
    prior_scheme: Optional[PRIOR_SCHEME]
    popen: float
    pextend: float
    def __init__(
        self,
        alphabet: ABC,
        *,
        architecture: ARCHITECTURE = "fast",
        weighting: WEIGHTING = "pb",
        effective_number: Union[EFFECTIVE, int, float] = "entropy",
        prior_scheme: Optional[PRIOR_SCHEME] = "alphabet",
        symfrac: float = 0.5,
        fragthresh: float = 0.5,
        wid: float = 0.62,
        esigma: float = 45.0,
        eid: float = 0.62,
        EmL: int = 200,
        EmN: int = 200,
        EvL: int = 200,
        EvN: int = 200,
        EfL: int = 100,
        EfN: int = 200,
        Eft: float = 0.04,
        seed: int = 42,
        ere: Optional[float] = None,
        popen: Optional[float] = None,
        pextend: Optional[float] = None,
        score_matrix: Optional[str] = None,
        window_length: Optional[int] = None,
        window_beta: Optional[float] = None,
    ) -> None: ...
    def __copy__(self) -> Builder[ABC]: ...
    @property
    def seed(self) -> int: ...
    @seed.setter
    def seed(self, seed: int) -> None: ...
    @property
    def window_length(self) -> Optional[int]: ...
    @window_length.setter
    def window_length(self, window_length: Optional[int]) -> None: ...
    @property
    def window_beta(self) -> Optional[float]: ...
    @window_beta.setter
    def window_beta(self, window_beta: Optional[float]) -> None: ...
    def build(
        self,
        sequence: DigitalSequence[ABC],
        background: Background[ABC],
    ) -> typing.Tuple[HMM[ABC], Profile[ABC], OptimizedProfile[ABC]]: ...
    def build_msa(
        self,
        msa: DigitalMSA[ABC],
        background: Background[ABC],
    ) -> typing.Tuple[HMM[ABC], Profile[ABC], OptimizedProfile[ABC]]: ...
    def copy(self) -> Builder[ABC]: ...

class Cutoffs(object):
    def __init__(self, owner: Union[Profile[Alphabet], HMM[Alphabet]]) -> None: ...
    def __copy__(self) -> Cutoffs: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def gathering(self) -> Optional[typing.Tuple[float, float]]: ...
    @gathering.setter
    def gathering(
        self, gathering: Optional[typing.Tuple[float, float]]
    ) -> None: ...
    @gathering.deleter
    def gathering(self) -> None: ...
    @property
    def gathering1(self) -> Optional[float]: ...
    @property
    def gathering2(self) -> Optional[float]: ...
    @property
    def trusted(self) -> Optional[typing.Tuple[float, float]]: ...
    @trusted.setter
    def trusted(self, trusted: Optional[typing.Tuple[float, float]]) -> None: ...
    @trusted.deleter
    def trusted(self) -> None: ...
    @property
    def trusted1(self) -> Optional[float]: ...
    @property
    def trusted2(self) -> Optional[float]: ...
    @property
    def noise(self) -> Optional[typing.Tuple[float, float]]: ...
    @noise.setter
    def noise(self, noise: Optional[typing.Tuple[float, float]]) -> None: ...
    @noise.deleter
    def noise(self) -> None: ...
    @property
    def noise1(self) -> Optional[float]: ...
    @property
    def noise2(self) -> Optional[float]: ...
    def gathering_available(self) -> bool: ...
    def trusted_available(self) -> bool: ...
    def noise_available(self) -> bool: ...
    def as_vector(self) -> VectorF: ...

class Domain(object):
    alignment: Alignment
    hit: Hit
    def __getstate__(self) -> Dict[str, object]: ...
    def __setstate__(self, state: Dict[str, object]) -> None: ...
    @property
    def env_from(self) -> int: ...
    @property
    def env_to(self) -> int: ...
    @property
    def strand(self) -> Optional[STRAND_SIGN]: ...
    @property
    def score(self) -> float: ...
    @property
    def bias(self) -> float: ...
    @property
    def correction(self) -> float: ...
    @property
    def envelope_score(self) -> float: ...
    @property
    def c_evalue(self) -> float: ...
    @property
    def i_evalue(self) -> float: ...
    @property
    def pvalue(self) -> float: ...
    @property
    def included(self) -> bool: ...
    @included.setter
    def included(self, included: bool) -> None: ...
    @property
    def reported(self) -> bool: ...
    @reported.setter
    def reported(self, reported: bool) -> None: ...

class Domains(typing.Sequence[Domain]):
    hit: Hit
    def __len__(self) -> int: ...
    def __getstate__(self) -> List[Dict[str, object]]: ...
    @typing.overload
    def __getitem__(self, index: int) -> Domain: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.Sequence[Domain]: ...
    @property
    def reported(self) -> SizedIterator[Domain]: ...
    @property
    def included(self) -> SizedIterator[Domain]: ...

class EvalueParameters:
    def __init__(self, owner: Union[Profile[Alphabet], HMM[Alphabet]]) -> None: ...
    def __copy__(self) -> EvalueParameters: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def m_mu(self) -> Optional[float]: ...
    @m_mu.setter
    def m_mu(self, m: Optional[float]) -> None: ...
    @property
    def m_lambda(self) -> Optional[float]: ...
    @m_lambda.setter
    def m_lambda(self, l: Optional[float]) -> None: ...
    @property
    def v_mu(self) -> Optional[float]: ...
    @v_mu.setter
    def v_mu(self, m: Optional[float]) -> None: ...
    @property
    def v_lambda(self) -> Optional[float]: ...
    @v_lambda.setter
    def v_lambda(self, l: Optional[float]) -> None: ...
    @property
    def f_tau(self) -> Optional[float]: ...
    @f_tau.setter
    def f_tau(self, t: Optional[float]) -> None: ...
    @property
    def f_lambda(self) -> Optional[float]: ...
    @f_lambda.setter
    def f_lambda(self, l: Optional[float]) -> None: ...
    def as_vector(self) -> VectorF: ...

class Hit(object):
    hits: TopHits[Any]
    def __getstate__(self) -> Dict[str, object]: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, name: Union[str, bytes]) -> None: ...
    @property
    def accession(self) -> Optional[str]: ...
    @accession.setter
    def accession(self, accession: Union[str, bytes, None]) -> None: ...
    @property
    def description(self) -> Optional[str]: ...
    @description.setter
    def description(self, description: Union[str, bytes, None]) -> None: ...
    @property
    def length(self) -> int: ...
    @property
    def score(self) -> float: ...
    @property
    def pre_score(self) -> float: ...
    @property
    def sum_score(self) -> float: ...
    @property
    def bias(self) -> float: ...
    @property
    def evalue(self) -> float: ...
    @property
    def pvalue(self) -> float: ...
    @property
    def domains(self) -> Domains: ...
    @property
    def best_domain(self) -> Domain: ...
    @property
    def included(self) -> bool: ...
    @included.setter
    def included(self, included: bool) -> None: ...
    @property
    def reported(self) -> bool: ...
    @reported.setter
    def reported(self, reported: bool) -> None: ...
    @property
    def new(self) -> bool: ...
    @new.setter
    def new(self, new: bool) -> None: ...
    @property
    def dropped(self) -> bool: ...
    @dropped.setter
    def dropped(self, dropped: bool) -> None: ...
    @property
    def duplicate(self) -> bool: ...
    @duplicate.setter
    def duplicate(self, duplicate: bool) -> None: ...

class HMM(typing.Generic[ABC]):
    alphabet: ABC
    @classmethod
    def sample(
        cls,
        alphabet: ABC,
        M: int,
        randomness: Union[Randomness, int, None] = None,
        ungapped: bool = False,
        enumerate: bool = False,
    ) -> HMM[ABC]: ...
    def __init__(self, alphabet: ABC, M: int, name: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __copy__(self) -> HMM[ABC]: ...
    def __deepcopy__(self, memo: Dict[int, object]) -> HMM[ABC]: ...
    def __sizeof__(self) -> int: ...
    def __getstate__(self) -> Dict[str, object]: ...
    def __setstate__(self, state: Dict[str, object]) -> None: ...
    @property
    def M(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, name: str) -> None: ...
    @property
    def accession(self) -> Optional[str]: ...
    @accession.setter
    def accession(self, accession: Union[str, bytes, None]) -> None: ...
    @property
    def checksum(self) -> Optional[int]: ...
    @property
    def composition(self) -> Optional[VectorF]: ...
    @property
    def description(self) -> Optional[str]: ...
    @description.setter
    def description(self, description: Union[str, bytes, None]) -> None: ...
    @property
    def consensus(self) -> Optional[str]: ...
    @property
    def consensus_structure(self) -> Optional[str]: ...
    @property
    def consensus_accessibility(self) -> Optional[str]: ...
    @property
    def command_line(self) -> Optional[str]: ...
    @command_line.setter
    def command_line(self, cli: Optional[str]) -> None: ...
    @property
    def nseq(self) -> Optional[int]: ...
    @property
    def nseq_effective(self) -> Optional[int]: ...
    @property
    def creation_time(self) -> Optional[datetime.datetime]: ...
    @creation_time.setter
    def creation_time(self, ctime: Optional[datetime.datetime]) -> None: ...
    @property
    def evalue_parameters(self) -> EvalueParameters: ...
    @property
    def cutoffs(self) -> Cutoffs: ...
    def copy(self) -> HMM[ABC]: ...
    def match_occupancy(self) -> VectorF: ...
    def mean_match_entropy(self) -> float: ...
    def mean_match_information(self, background: Background[ABC]) -> float: ...
    def mean_match_relative_entropy(self, background: Background[ABC]) -> float: ...
    def renormalize(self) -> None: ...
    def scale(self, scale: float, exponential: bool = False) -> None: ...
    def set_composition(self) -> None: ...
    def set_consensus(self, sequence: Optional[DigitalSequence[ABC]]) -> None: ...
    def to_profile(
        self,
        background: Optional[Background[ABC]] = None,
        L: int = 400,
        multihit: bool = True,
        local: bool = True,
    ) -> Profile[ABC]: ...
    def validate(self, tolerance: float = ...) -> None: ...
    def write(self, fh: typing.BinaryIO, binary: bool = False) -> None: ...
    def zero(self) -> None: ...

class HMMFile(typing.Generic[ABC], typing.ContextManager[HMMFile[ABC]], typing.Iterator[HMM[ABC]]):
    _FORMATS: ClassVar[Dict[str, int]]
    _MAGIC: ClassVar[Dict[int, int]]
    def __init__(
        self,
        file: Union[typing.AnyStr, os.PathLike[typing.AnyStr], typing.BinaryIO],
        db: bool = True,
    ) -> None: ...
    def __enter__(self) -> HMMFile[ABC]: ...
    def __exit__(
        self,
        exc_type: Optional[typing.Type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> bool: ...
    def __iter__(self) -> HMMFile[ABC]: ...
    def __next__(self) -> HMM[ABC]: ...
    def __repr__(self) -> str: ...
    @property
    def closed(self) -> bool: ...
    @property
    def name(self) -> Optional[str]: ...
    def close(self) -> None: ...
    def is_pressed(self) -> bool: ...
    def read(self) -> Optional[HMM[ABC]]: ...
    def rewind(self) -> None: ...
    def optimized_profiles(self) -> HMMPressedFile[ABC]: ...

class HMMPressedFile(typing.Generic[ABC], typing.ContextManager[HMMPressedFile[ABC]], typing.Iterator[OptimizedProfile[ABC]]):
    def __init__(
        self,
        file: Union[typing.AnyStr, os.PathLike[typing.AnyStr]],
    ) -> None: ...
    def __enter__(self) -> HMMPressedFile[ABC]: ...
    def __exit__(
        self,
        exc_type: Optional[typing.Type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> bool: ...
    def __iter__(self) -> HMMPressedFile[ABC]: ...
    def __next__(self) -> OptimizedProfile[ABC]: ...
    def __len__(self) -> int: ...
    @property
    def closed(self) -> bool: ...
    @property
    def name(self) -> str: ...
    def close(self) -> None: ...
    def read(self) -> Optional[OptimizedProfile[ABC]]: ...
    def rewind(self) -> None: ...

class IterationResult(typing.Generic[ABC], typing.NamedTuple):
    hmm: HMM[ABC]
    hits: TopHits[HMM[ABC]]
    msa: DigitalMSA[ABC]
    converged: bool
    iteration: int

class IterativeSearch(typing.Generic[ABC], typing.Iterator[IterationResult[ABC]]):
    pipeline: Pipeline[ABC]
    builder: Builder[ABC]
    query: Union[DigitalSequence[ABC], HMM[ABC]]
    converged: bool
    targets: DigitalSequenceBlock[ABC]
    ranking: KeyHash
    iteration: int
    def __init__(
        self,
        pipeline: Pipeline[ABC],
        builder: Builder[ABC],
        query: Union[DigitalSequence[ABC], HMM[ABC]],
        targets: DigitalSequenceBlock[ABC],
        select_hits: Optional[typing.Callable[[TopHits[HMM[ABC]]], None]] = None,
    ) -> None: ...
    def __iter__(self) -> IterativeSearch[ABC]: ...
    def __next__(self) -> IterationResult[ABC]: ...

class OptimizedProfile(typing.Generic[ABC]):
    alphabet: ABC
    def __init__(self, M: int, abc: ABC) -> None: ...
    def __copy__(self) -> OptimizedProfile[ABC]: ...
    def __deepcopy__(self, memo: Dict[int, object]) -> OptimizedProfile[ABC]: ...
    def __eq__(self, other: object) -> bool: ...
    def __sizeof__(self) -> int: ...
    @property
    def M(self) -> int: ...
    @property
    def L(self) -> int: ...
    @L.setter
    def L(self, L: int) -> None: ...
    @property
    def name(self) -> Optional[str]: ...
    @property
    def accession(self) -> Optional[str]: ...
    @property
    def description(self) -> Optional[str]: ...
    @property
    def consensus(self) -> Optional[str]: ...
    @property
    def consensus_structure(self) -> Optional[str]: ...
    @property
    def reference(self) -> Optional[str]: ...
    @property
    def model_mask(self) -> Optional[str]: ...
    # --- MSV Filter ---
    @property
    def rbv(self) -> MatrixU8: ...
    @property
    def sbv(self) -> MatrixU8: ...
    @property
    def tbm(self) -> int: ...
    @property
    def tec(self) -> int: ...
    @property
    def tjb(self) -> int: ...
    @property
    def scale_b(self) -> float: ...
    @property
    def base_b(self) -> int: ...
    @property
    def bias_b(self) -> int: ...
    # --- ViterbiFilter ---
    @property
    def scale_w(self) -> float: ...
    @property
    def base_w(self) -> int: ...
    @property
    def ddbound_w(self) -> int: ...
    @property
    def ncj_roundoff(self) -> float: ...
    # --- Forward, Backard ---
    @property
    def rfv(self) -> MatrixF: ...
    @property
    def tfv(self) -> VectorF: ...
    @property
    def xf(self) -> MatrixF: ...
    # --- Miscellaneous ---
    @property
    def offsets(self) -> Offsets: ...
    @property
    def evalue_parameters(self) -> EvalueParameters: ...
    @property
    def cutoffs(self) -> Cutoffs: ...
    @property
    def compositions(self) -> VectorF: ...
    @property
    def local(self) -> bool: ...
    @property
    def multihit(self) -> bool: ...
    @multihit.setter
    def multihit(self, multihit: bool) -> None: ...
    def copy(self) -> OptimizedProfile[ABC]: ...
    def write(
        self, fh_filter: typing.BinaryIO, fh_profile: typing.BinaryIO
    ) -> None: ...
    def convert(self, profile: Profile[ABC]) -> None: ...
    def ssv_filter(self, seq: DigitalSequence[ABC]) -> Optional[float]: ...

class OptimizedProfileBlock(typing.Generic[ABC], typing.MutableSequence[OptimizedProfile[ABC]]):
    alphabet: ABC
    def __init__(
        self, 
        alphabet: ABC, 
        iterable: Iterable[OptimizedProfile[ABC]] = ()
    ) -> None: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> OptimizedProfile[ABC]: ...
    @typing.overload
    def __getitem__(self, index: slice) -> OptimizedProfileBlock[ABC]: ...
    @typing.overload
    def __setitem__(self, index: int, optimized_profile: OptimizedProfile[ABC]) -> None: ...
    @typing.overload
    def __setitem__(
        self, index: slice, optimized_profile: Iterable[OptimizedProfile[ABC]]
    ) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    def __repr__(self) -> str: ...
    def __contains__(self, item: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __copy__(self) -> OptimizedProfileBlock[ABC]: ...
    def copy(self) -> OptimizedProfileBlock[ABC]: ...
    def clear(self) -> None: ...
    def append(self, optimized_profile: OptimizedProfile[ABC]) -> None: ...
    def extend(self, iterable: Iterable[OptimizedProfile[ABC]]) -> None: ...
    def pop(self, index: int = -1) -> OptimizedProfile[ABC]: ...
    def insert(self, index: int, optimized_profile: OptimizedProfile[ABC]) -> None: ...
    def index(
        self,
        optimized_profile: OptimizedProfile[ABC],
        start: int = 0,
        end: int = sys.maxsize,
    ) -> int: ...
    def remove(self, optimized_profile: OptimizedProfile[ABC]) -> None: ...

class Offsets(object):
    def __init__(self, owner: Union[Profile[Alphabet], OptimizedProfile[Alphabet]]) -> None: ...
    def __copy__(self) -> Offsets: ...
    def __repr__(self) -> str: ...
    @property
    def model(self) -> Optional[int]: ...
    @model.setter
    def model(self, model: Optional[int]) -> None: ...
    @property
    def filter(self) -> Optional[int]: ...
    @filter.setter
    def filter(self, filter: Optional[int]) -> None: ...
    @property
    def profile(self) -> Optional[int]: ...
    @profile.setter
    def profile(self, profile: Optional[int]) -> None: ...

class Pipeline(typing.Generic[ABC]):
    M_HINT: ClassVar[int] = 100
    L_HINT: ClassVar[int] = 100
    _BIT_CUTOFFS: ClassVar[Dict[str, int]]
    alphabet: ABC
    background: Background[ABC]
    profile: Optional[Profile[ABC]]
    randomness: Randomness
    def __init__(
        self,
        alphabet: ABC,
        background: Optional[Background[ABC]] = None,
        *,
        bias_filter: bool = True,
        null2: bool = True,
        seed: int = 42,
        Z: Optional[float] = None,
        domZ: Optional[float] = None,
        F1: float = 0.02,
        F2: float = 1e-3,
        F3: float = 1e-5,
        E: float = 10.0,
        T: Optional[float] = None,
        domE: float = 10.0,
        domT: Optional[float] = None,
        incE: float = 0.01,
        incT: Optional[float] = None,
        incdomE: float = 0.01,
        incdomT: Optional[float] = None,
        bit_cutoffs: Optional[BIT_CUTOFFS] = None,
    ) -> None: ...
    @property
    def Z(self) -> Optional[float]: ...
    @Z.setter
    def Z(self, Z: Optional[float]) -> None: ...
    @property
    def domZ(self) -> Optional[float]: ...
    @domZ.setter
    def domZ(self, domZ: Optional[float]) -> None: ...
    @property
    def null2(self) -> bool: ...
    @null2.setter
    def null2(self, null2: bool) -> None: ...
    @property
    def bias_filter(self) -> bool: ...
    @bias_filter.setter
    def bias_filter(self, bias_filter: bool) -> None: ...
    @property
    def F1(self) -> float: ...
    @F1.setter
    def F1(self, F1: float) -> None: ...
    @property
    def F2(self) -> float: ...
    @F2.setter
    def F2(self, F2: float) -> None: ...
    @property
    def F3(self) -> float: ...
    @F3.setter
    def F3(self, F3: float) -> None: ...
    @property
    def E(self) -> float: ...
    @E.setter
    def E(self, E: float) -> None: ...
    @property
    def T(self) -> Optional[float]: ...
    @T.setter
    def T(self, T: Optional[float]) -> None: ...
    @property
    def domE(self) -> float: ...
    @domE.setter
    def domE(self, domE: float) -> None: ...
    @property
    def domT(self) -> Optional[float]: ...
    @domT.setter
    def domT(self, domT: Optional[float]) -> None: ...
    @property
    def incE(self) -> float: ...
    @incE.setter
    def incE(self, incE: float) -> None: ...
    @property
    def incT(self) -> Optional[float]: ...
    @incT.setter
    def incT(self, incT: Optional[float]) -> None: ...
    @property
    def incdomE(self) -> float: ...
    @incdomE.setter
    def incdomE(self, incdomE: float) -> None: ...
    @property
    def incdomT(self) -> Optional[float]: ...
    @incdomT.setter
    def incdomT(self, incdomT: Optional[float]) -> None: ...
    @property
    def bit_cutoffs(self) -> Optional[BIT_CUTOFFS]: ...
    @bit_cutoffs.setter
    def bit_cutoffs(self, bit_cutoffs: Optional[BIT_CUTOFFS]) -> None: ...
    def arguments(self) -> List[str]: ...
    def clear(self) -> None: ...
    def search_hmm(
        self,
        query: Union[HMM[ABC], Profile[ABC], OptimizedProfile[ABC]],
        sequences: Union[DigitalSequenceBlock[ABC], SequenceFile[DigitalSequence[ABC]]],
    ) -> TopHits[Union[HMM[ABC], Profile[ABC], OptimizedProfile[ABC]]]: ...
    def search_msa(
        self,
        query: DigitalMSA[ABC],
        sequences: Union[DigitalSequenceBlock[ABC], SequenceFile[DigitalSequence[ABC]]],
        builder: Optional[Builder[ABC]] = None,
    ) -> TopHits[DigitalMSA]: ...
    def search_seq(
        self,
        query: DigitalSequence,
        sequences: Union[DigitalSequenceBlock[ABC], SequenceFile[DigitalSequence[ABC]]],
        builder: Optional[Builder[ABC]] = None,
    ) -> TopHits[DigitalSequence]: ...
    def scan_seq(
        self,
        query: DigitalSequence[ABC],
        optimized_profiles: Union[OptimizedProfileBlock[ABC], HMMPressedFile[ABC]],
    ) -> TopHits[DigitalSequence[ABC]]: ...
    def iterate_seq(
        self,
        query: DigitalSequence[ABC],
        sequences: DigitalSequenceBlock[ABC],
        builder: Optional[Builder[ABC]] = None,
        select_hits: Optional[typing.Callable[[TopHits[DigitalSequence[ABC]]], None]] = None,
    ) -> IterativeSearch[ABC]: ...
    def iterate_hmm(
        self,
        query: HMM[ABC],
        sequences: DigitalSequenceBlock[ABC],
        builder: Optional[Builder[ABC]] = None,
        select_hits: Optional[typing.Callable[[TopHits[DigitalSequence[ABC]]], None]] = None,
    ) -> IterativeSearch[ABC]: ...

class LongTargetsPipeline(typing.Generic[ABC], Pipeline[ABC]):
    def __init__(
        self,
        alphabet: ABC,
        background: Optional[Background[ABC]] = None,
        *,
        strand: Optional[STRAND] = None,
        B1: int = 100,
        B2: int = 240,
        B3: int = 1000,
        block_length: int = 1024 * 256,
        window_length: Optional[int] = None,
        window_beta: Optional[float] = None,
        bias_filter: bool = True,
        null2: bool = True,
        seed: Optional[int] = None,
        Z: Optional[float] = None,
        domZ: Optional[float] = None,
        F1: float = 0.02,
        F2: float = 1e-3,
        F3: float = 1e-5,
        E: float = 10.0,
        T: Optional[float] = None,
        domE: float = 10.0,
        domT: Optional[float] = None,
        incE: float = 0.01,
        incT: Optional[float] = None,
        incdomE: float = 0.01,
        incdomT: Optional[float] = None,
        bit_cutoffs: Optional[BIT_CUTOFFS] = None,
    ) -> None: ...
    @property
    def B1(self) -> int: ...
    @B1.setter
    def B1(self, B1: int) -> None: ...
    @property
    def B2(self) -> int: ...
    @B2.setter
    def B2(self, B2: int) -> None: ...
    @property
    def B3(self) -> int: ...
    @B3.setter
    def B3(self, B3: int) -> None: ...
    @property
    def strand(self) -> Optional[STRAND]: ...
    @strand.setter
    def strand(self, strand: Optional[STRAND]) -> None: ...
    @property
    def window_beta(self) -> float: ...
    @window_beta.setter
    def window_beta(self, window_beta: float) -> None: ...
    @property
    def window_length(self) -> Optional[int]: ...
    @window_length.setter
    def window_length(self, window_length: Optional[int]) -> None: ...

class Profile(typing.Generic[ABC]):
    alphabet: ABC
    def __init__(self, M: int, alphabet: ABC) -> None: ...
    def __copy__(self) -> Profile[ABC]: ...
    def __deepcopy__(self, memo: Dict[int, object]) -> Profile[ABC]: ...
    def __eq__(self, other: object) -> bool: ...
    def __sizeof__(self) -> int: ...
    @property
    def M(self) -> int: ...
    @property
    def name(self) -> Optional[str]: ...
    @property
    def accession(self) -> Optional[str]: ...
    @property
    def description(self) -> Optional[str]: ...
    @property
    def consensus(self) -> Optional[str]: ...
    @property
    def consensus_structure(self) -> Optional[str]: ...
    @property
    def cutoffs(self) -> Cutoffs: ...
    @property
    def evalue_parameters(self) -> EvalueParameters: ...
    @property
    def offsets(self) -> Offsets: ...
    @property
    def local(self) -> bool: ...
    @property
    def multihit(self) -> bool: ...
    @multihit.setter
    def multihit(self, multihit: bool) -> None: ...
    def clear(self) -> None: ...
    def configure(
        self,
        hmm: HMM[ABC],
        background: Background[ABC],
        L: int = 400,
        multihit: bool = True,
        local: bool = True,
    ) -> None: ...
    def copy(self) -> Profile[ABC]: ...
    def to_optimized(self) -> OptimizedProfile[ABC]: ...

class ScoreData(object):
    Kp: int
    def __init__(self, gm: Profile[ABC], om: OptimizedProfile[ABC]) -> None: ...
    def __copy__(self) -> ScoreData: ...
    def copy(self) -> ScoreData: ...

class TopHits(typing.Sequence[Hit], typing.Generic[Q]):
    def __init__(self, query: Q) -> None: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> TopHits[Q]: ...
    def __deepcopy__(self, memo: Dict[int, object]) -> TopHits[Q]: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Hit: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.Sequence[Hit]: ...
    def __iadd__(self, other: TopHits[Q]) -> TopHits[Q]: ...
    def __getstate__(self) -> Dict[str, object]: ...
    def __setstate__(self, state: Dict[str, object]) -> None: ...
    @property
    def mode(self) -> HITS_MODE: ...
    @property
    def query(self) -> Q: ...
    @property
    def Z(self) -> float: ...
    @property
    def domZ(self) -> float: ...
    @property
    def long_targets(self) -> bool: ...
    @property
    def E(self) -> float: ...
    @property
    def T(self) -> Optional[float]: ...
    @property
    def domE(self) -> float: ...
    @property
    def domT(self) -> Optional[float]: ...
    @property
    def incE(self) -> float: ...
    @property
    def incT(self) -> Optional[float]: ...
    @property
    def incdomE(self) -> float: ...
    @property
    def incdomT(self) -> Optional[float]: ...
    @property
    def bit_cutoffs(self) -> Optional[BIT_CUTOFFS]: ...
    @property
    def searched_models(self) -> int: ...
    @property
    def searched_nodes(self) -> int: ...
    @property
    def searched_sequences(self) -> int: ...
    @property
    def searched_residues(self) -> int: ...
    @property
    def strand(self) -> Optional[STRAND]: ...
    @property
    def block_length(self) -> Optional[int]: ...
    @property
    def reported(self) -> SizedIterator[Hit]: ...
    @property
    def included(self) -> SizedIterator[Hit]: ...
    def compare_ranking(self, ranking: KeyHash) -> int: ...
    def sort(self, by: SORT_KEY = "key") -> None: ...
    def is_sorted(self, by: SORT_KEY = "key") -> bool: ...
    def copy(self) -> TopHits[Q]: ...
    def merge(self, *others: TopHits[Q]) -> TopHits[Q]: ...
    def to_msa(
        self,
        alphabet: Alphabet,
        sequences: Optional[List[Sequence]] = None,
        traces: Optional[List[Trace]] = None,
        *,
        trim: bool = False,
        digitize: bool = False,
        all_consensus_cols: bool = False,
    ) -> MSA: ...
    def write(
        self,
        fh: typing.BinaryIO,
        format: HITS_FORMAT = "targets",
        header: bool = True,
    ) -> None: ...

class Trace(object):
    @classmethod
    def from_sequence(cls, sequence: Sequence) -> Trace: ...
    def __init__(self, posteriors: bool = False) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def M(self) -> int: ...
    @property
    def L(self) -> int: ...
    @property
    def posterior_probabilities(self) -> Optional[VectorF]: ...
    def expected_accuracy(self) -> float: ...
    def score(self, sequence: DigitalSequence[ABC], profile: Profile[ABC]) -> float: ...

class Traces(typing.MutableSequence[Trace]):
    def __init__(self, iterable: Iterable[Trace] = ()) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Trace: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[Trace]: ...
    @typing.overload
    def __setitem__(self, index: int, item: Trace) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, item: Iterable[Trace]) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    def __contains__(self, other: object) -> bool: ...
    def append(self, trace: Trace) -> None: ...
    def clear(self) -> None: ...
    def extend(self, iterable: Iterable[Trace]) -> None: ...
    def pop(self, index: int = -1) -> Trace: ...
    def insert(self, index: int, trace: Trace) -> None: ...
    def index(self, trace: Trace, start: int = 0, stop: int = sys.maxsize) -> int: ...
    def remove(self, trace: Trace) -> None: ...

class TraceAligner(object):
    def __init__(self) -> None: ...
    def compute_traces(
        self,
        hmm: HMM[ABC],
        sequences: DigitalSequenceBlock[ABC],
    ) -> Traces: ...
    @typing.overload
    def align_traces(
        self,
        hmm: HMM[ABC],
        sequences: DigitalSequenceBlock[ABC],
        traces: Traces,
        digitize: Literal[True],
        trim: bool = False,
        all_consensus_cols: bool = False,
    ) -> DigitalMSA[ABC]: ...
    @typing.overload
    def align_traces(
        self,
        hmm: HMM[ABC],
        sequences: DigitalSequenceBlock[ABC],
        traces: Traces,
        digitize: Literal[False],
        trim: bool = False,
        all_consensus_cols: bool = False,
    ) -> TextMSA: ...
    @typing.overload
    def align_traces(
        self,
        hmm: HMM[ABC],
        sequences: DigitalSequenceBlock[ABC],
        traces: Traces,
        digitize: bool = False,
        trim: bool = False,
        all_consensus_cols: bool = False,
    ) -> MSA: ...

class Transitions(enum.IntEnum):
    MM = ...
    MI = ...
    MD = ...
    IM = ...
    II = ...
    DM = ...
    DD = ...
